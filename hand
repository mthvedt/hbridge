module Hand where
import System.Random
import System.Random.Shuffle
import Control.Monad.Random
import Control.Monad.Random.Class
import Control.Monad.State
import Data.List.Split
import Data.Functor
import Data.List

data Suit = Club | Diamond | Heart | Spade
    deriving (Read, Show, Enum, Eq, Ord)

data Direction = North | East | South | West
    deriving (Read, Show, Enum, Eq, Ord)

showShort Club = "C"
showShort Diamond = "D"
showShort Heart = "H"
showShort Spade = "S"

showRank 8 = "T"
showRank 9 = "J"
showRank 10 = "Q"
showRank 11 = "K"
showRank 12 = "A"
showRank x = show $ x + 2
    
data Card = Card {rank :: Int, suit :: Suit}
    deriving (Read, Eq)

instance Ord Card where
   compare (Card r1 s1) (Card r2 s2)
        | s1 /= s2 = compare s1 s2
        | r1 /= r2 = compare r1 r2
        | otherwise = EQ

instance Show Card where
    show (Card r s) = showRank r ++ showShort s

fulldeck = [Card v s | v <- [0 .. 12], s <- [Club .. Spade]]

data Hand = Hand {north :: [Card], east :: [Card], south :: [Card], west :: [Card]}
    deriving (Eq, Read, Show)

dealHand d =
    let [north, east, south, west] = reverse <$> sort <$> chunksOf 13 d
        in Hand north east south west

randDealM :: (RandomGen g) => Rand g Hand
randDealM = liftM dealHand $ shuffleM fulldeck

data Board = Board {deal :: Hand, dealer :: Direction, trump :: Suit}
    deriving (Read, Eq, Show)

randBoardM :: (RandomGen g) => Rand g Board
randBoardM = do
    d <- randDealM
    trump <- liftM toEnum $ getRandomR (0, 3)
    suit <- liftM toEnum $ getRandomR (0, 3)
    return $ Board d trump suit